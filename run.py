import copy
from sklearn.metrics import mean_squared_error
from math import sqrt
import numpy as np
import random
import os
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
from adaTransformer import Transformer
from data_loader import load, load_from_pickle


device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')


def build_sequences(text, window_size):
    # text:list of capacity
    x, y = [], []
    for i in range(len(text) - window_size):
        sequence = text[i:i+window_size]
        target = text[i+1:i+1+window_size]

        x.append(sequence)
        y.append(target)

    return np.array(x), np.array(y)


# leave-one-out evaluation: one battery is sampled randomly; the remainder are used for training.
def get_train_test(data_dict, name, window_size=8):
    data_sequence = data_dict[name]['capacity']
    train_data, test_data = data_sequence[:window_size +
                                          1], data_sequence[window_size+1:]
    train_x, train_y = build_sequences(
        text=train_data, window_size=window_size)
    for k, v in data_dict.items():
        if k != name:
            data_x, data_y = build_sequences(
                text=v['capacity'], window_size=window_size)
            train_x, train_y = np.r_[train_x, data_x], np.r_[train_y, data_y]

    return train_x, train_y, list(train_data), list(test_data)


def relative_error(y_test, y_predict, threshold):
    true_re, pred_re = len(y_test), 0
    for i in range(len(y_test)-1):
        if y_test[i] <= threshold >= y_test[i+1]:
            true_re = i - 1
            break
    for i in range(len(y_predict)-1):
        if y_predict[i] <= threshold:
            pred_re = i - 1
            break
    return abs(true_re - pred_re)/true_re if abs(true_re - pred_re)/true_re <= 1 else 1


def evaluation(y_test, y_predict):
    mse = mean_squared_error(y_test, y_predict)
    rmse = sqrt(mean_squared_error(y_test, y_predict))
    return rmse


def setup_seed(seed):
    np.random.seed(seed)  # Numpy module.
    random.seed(seed)  # Python random module.
    os.environ['PYTHONHASHSEED'] = str(seed)
    torch.manual_seed(seed)
    if torch.cuda.is_available():
        torch.cuda.manual_seed(seed)
        torch.cuda.manual_seed_all(seed)
        torch.backends.cudnn.benchmark = False
        torch.backends.cudnn.deterministic = True


def train(Battery, Battery_list=['CS2_35', 'CS2_36'], lr=0.01, feature_size=8, hidden_dim=32, num_layers=1, nhead=8, weight_decay=0.0, EPOCH=1000, seed=0,
          alpha=0.0, noise_level=0.0, dropout=0.0, metric='re', is_load_weights=True, rated_capacity=1.1):
    score_list, result_list = [], []

    for i in range(len(Battery_list)):
        name = Battery_list[i]
        window_size = feature_size
        train_x, train_y, train_data, test_data = get_train_test(
            Battery, name, window_size)
        train_size = len(train_x)
        print('sample size: {}'.format(train_size))

        setup_seed(seed)
        model = Transformer(feature_size=feature_size, hidden_dim=hidden_dim, num_layers=num_layers, nhead=nhead, dropout=dropout,
                            noise_level=noise_level)
        model = model.to(device)
        optimizer = torch.optim.Adam(
            model.parameters(), lr=lr, weight_decay=weight_decay)
        criterion = nn.MSELoss()

        '''
        # save ramdom data for repetition
        if torch.__version__.split('+')[0] >= '1.6.0':
            torch.save(model.state_dict(), 'model_CALCE'+str(seed)+'.pth')
        else:
            torch.save(model.state_dict(), 'model_CALCE.pth', _use_new_zipfile_serialization=False)
         '''

        # load the random data generated by my device
        if is_load_weights:
            if torch.__version__.split('+')[0] >= '1.6.0':
                model.load_state_dict(torch.load(
                    'initial_weights/model_CALCE.pth'))
            else:
                model.load_state_dict(torch.load(
                    'initial_weights/model_CALCE_1.5.0.pth'))

        test_x = train_data.copy()
        loss_list, y_ = [0], []
        rmse, re = 1, 1
        score_, score = [1], [1]
        weight_mat = None
        dist_old = None
        for epoch in range(EPOCH):

            # (batch_size, seq_len, input_size)
            X = np.reshape(train_x/rated_capacity,
                           (-1, 1, feature_size)).astype(np.float32)
            # print(X.shape)
            dist_mat = torch.zeros(num_layers, X.shape[1])

            # shape 为 (batch_size, 1)
            y = np.reshape(train_y[:, -1]/rated_capacity,
                           (-1, 1)).astype(np.float32)

            X, y = torch.from_numpy(X).to(
                device), torch.from_numpy(y).to(device)
            output, decode, list_encoding = model(X)
            loss_adapt, dist, weight_mat = model.adapt_encoding_weight(
                list_encoding, weight_mat)
            dist_mat = dist_mat.to(device)
            dist = dist.to(device)
            dist_mat = dist_mat + dist
            output = output.reshape(-1, 1)
            loss = criterion(output, y) + \
                criterion(decode, X.reshape(-1, feature_size)) \
                + alpha * loss_adapt
            optimizer.zero_grad()              # clear gradients for this training step
            loss.backward()                    # backpropagation, compute gradients
            optimizer.step()                   # apply gradients
            if epoch > 0:
                weight_mat = model.update_weight_Boosting(
                    weight_mat, dist_old, dist_mat)
            dist_old = dist_mat
            if (epoch + 1) % 10 == 0:
                test_x = train_data.copy()
                point_list = []
                while (len(test_x) - len(train_data)) < len(test_data):
                    x = np.reshape(np.array(
                        test_x[-feature_size:])/rated_capacity, (-1, 1, feature_size)).astype(np.float32)
                    # (batch_size,feature_size=1,input_size)
                    x = torch.from_numpy(x).to(device)
                    # pred shape (batch_size=1, feature_size=1)
                    pred, _, _ = model(x)
                    next_point = pred.data.cpu().numpy()[0, 0] * rated_capacity
                    # The test values are added to the original sequence to continue to predict the next point
                    test_x.append(next_point)
                    # Saves the predicted value of the last point in the output sequence
                    point_list.append(next_point)
                # Save all the predicted values
                y_.append(point_list)
                loss_list.append(loss)
                rmse = evaluation(y_test=test_data, y_predict=y_[-1])
                re = relative_error(
                    y_test=test_data, y_predict=y_[-1], threshold=rated_capacity*0.7)
                #print('epoch:{:<2d} | loss:{:<6.4f} | RMSE:{:<6.4f} | RE:{:<6.4f}'.format(epoch, loss, rmse, re))
            if metric == 're':
                score = [re]
            elif metric == 'rmse':
                score = [rmse]
            else:
                score = [re, rmse]
            if (loss < 0.001) and (score_[0] < score[0]):
                break
            score_ = score.copy()

        score_list.append(score_)
        result_list.append(y_[-1])
    return score_list, result_list,model

def predict(Battery,Battery_list,model,rated_capacity=1.1,feature_size=8,window_size=64):
    result_list = []
    for i in range(len(Battery_list)):
        name = Battery_list[i]
        aa = Battery[name]['capacity'][:window_size + 1]
        pred_list = copy(aa)
        while len(pred_list) < len(Battery[name]['capacity']):
            train_x = build_sequences(text=aa,window_size=window_size)
            X = np.reshape(train_x/rated_capacity,
                           (-1, 1, feature_size)).astype(np.float32)
            X = torch.from_numpy(X).to(device)
            pred,_,_ = model(X)
            next_point = pred.data.cpu().numpy()[0,0]* rated_capacity
            aa.append(next_point)
            aa = aa[1:]
            pred_list.append(next_point)
        result_list.append(pred_list)
    return result_list
        

# Rated_Capacity = 1.1
# window_size = 64
# feature_size = window_size
# dropout = 0.0
# EPOCH = 500
# nhead = 16
# weight_decay = 0.0
# noise_level = 0.0
# alpha = 0.01
# lr = 0.0005    # learning rate
# hidden_dim = 32
# num_layers = 1
# is_load_weights = False
# metric = 're'
# re mean: 0.0536
#
# Rated_Capacity = 1.1
# window_size = 64
# feature_size = window_size
# dropout = 0.0
# EPOCH = 500
# nhead = 16
# weight_decay = 0.0
# noise_level = 0.0
# alpha = 0.01
# lr = 0.0005    # learning rate
# hidden_dim = 32
# num_layers = 1
# is_load_weights = False
# metric = 'rmse'
# rmse mean: 0.0690


def get_optimal_params():
    Rated_Capacity = 1.1
    window_size = 64
    feature_size = window_size
    dropout = 0.0
    EPOCH = 20
    nhead = 16
    is_load_weights = False
    weight_decay = 0.0
    noise_level = 0.0
    num_layers = 1
    metric = 're'

    Battery_list = ['CS2_35', 'CS2_36']
    Battery = load(Battery_list)

    states = {}
    for lr in [1e-4, 5e-4, 1e-3, 1e-2]:
        for hidden_dim in [16, 32, 64]:
            for alpha in [1e-4, 1e-3, 1e-2]:
                show_str = 'lr={}, num_layers={}, hidden_dim={}'.format(
                    lr, num_layers, hidden_dim)
                print(show_str)
                SCORE = []
                for seed in range(5):
                    print('seed:{}'.format(seed))
                    score_list, _ = train(Battery=Battery, Battery_list=Battery_list, lr=lr, feature_size=feature_size, hidden_dim=hidden_dim, num_layers=num_layers, nhead=nhead,
                                          weight_decay=weight_decay, EPOCH=EPOCH, seed=seed, dropout=dropout, alpha=alpha,
                                          noise_level=noise_level, metric=metric, is_load_weights=is_load_weights, rated_capacity=Rated_Capacity)
                    print(np.array(score_list))
                    print(
                        metric + ': {:<6.4f}'.format(np.mean(np.array(score_list))))
                    print(
                        '------------------------------------------------------------------')
                    for s in score_list:
                        SCORE.append(s)

                print(
                    metric + ' mean: {:<6.4f}'.format(np.mean(np.array(SCORE))))
                states[show_str] = np.mean(np.array(SCORE))
                print(
                    '===================================================================')

    min_key = min(states, key=states.get)
    print('optimal parameters: {}, result: {}'.format(
        min_key, states[min_key]))


def main():
    Rated_Capacity = 1.1
    window_size = 64
    feature_size = window_size
    dropout = 0.0
    EPOCH = 2000
    nhead = 16
    weight_decay = 0.0
    noise_level = 0.0
    alpha = 0.01
    lr = 0.0005    # learning rate
    hidden_dim = 64
    num_layers = 1
    is_load_weights = False
    metric = 'rmse'
    train_size = 55

    seed = 0
    SCORE = []
    train_batteries, train_names, test_batteries, test_names = load_from_pickle(
        train_size=train_size)
    # Battery_list = ['CS2_35', 'CS2_36']
    # Battery = load(Battery_list)

    print('seed:{}'.format(seed))
    score_list, result_list,model = train(Battery=train_batteries, Battery_list=train_names, lr=lr, feature_size=feature_size, hidden_dim=hidden_dim, num_layers=num_layers, nhead=nhead,
                                    weight_decay=weight_decay, EPOCH=EPOCH, seed=seed, dropout=dropout, alpha=alpha,
                                    noise_level=noise_level, metric=metric, is_load_weights=is_load_weights, rated_capacity=Rated_Capacity)
    print(np.array(score_list))
    print(metric + ': {:<6.4f}'.format(np.mean(np.array(score_list))))
    print('------------------------------------------------------------------')
    for s in score_list:
        SCORE.append(s)

    print(metric + ' mean: {:<6.4f}'.format(np.mean(np.array(SCORE))))
    print(len(result_list[0]))

    for i in range(len(train_names)):
        name = train_names[i]
        train_x, train_y, train_data, test_data = get_train_test(
            train_batteries, name, window_size)

        aa = train_data[:window_size+1].copy()  # 第一个输入序列
        [aa.append(a) for a in result_list[i]]  # 测试集预测结果

        battery = train_batteries[name]
        fig, ax = plt.subplots(1, figsize=(12, 8))
        ax.plot(battery['cycle'], battery['capacity'], 'b.', label=name)
        ax.plot(battery['cycle'], aa, 'r.', label='Prediction')
        plt.plot([-1, 1000], [Rated_Capacity*0.7, Rated_Capacity*0.7],
                 c='black', lw=1, ls='--')  # 临界点直线
        plt.axvline(window_size)
        ax.set(xlabel='Discharge cycles', ylabel='Capacity (Ah)')
        ax.set_title(f'Train set {name}')
        plt.legend()
        plt.savefig(f'./result/train/{name}.png')

    predict_results = predict(test_batteries,test_names,model)
    for i in range(len(test_names)):
        name = test_names[i]
        battery = test_batteries[name]
        fig, ax = plt.subplots(1,figsize=(12,8))
        ax.plot(battery['cycle'],battery['capacity'],'b.',label=name)
        ax.plot(battery['cycle'],predict_results[i])
        plt.plot([-1, 1000], [Rated_Capacity*0.7, Rated_Capacity*0.7],
                 c='black', lw=1, ls='--')
        plt.axvline(window_size)
        ax.set(xlabel='Discharge cycles', ylabel='Capacity (Ah)')
        ax.set_title(f'Test set {name}')
        plt.legend()
        plt.savefig(f'./result/test/{name}.png')
    print('Done ....')

if __name__ == "__main__":
    main()
